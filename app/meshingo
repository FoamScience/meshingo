#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
meshingo_usage() {
  if [[ -n $long_usage ]]; then
    printf "meshingo\n\n"
    printf "  A cell-size recommendation system for CFD meshes;\n  \n  **Idea**:\n  \n  From an STL file describing the (water-tight) flow domain, guess a\n  \"good-enough\" minimal cell size (to be used at feature-edges) and a ratio\n  between smallest and biggest cell size in the mesh. These parameters can then\n  be used to mesh the surface STLs in an **unattended way**.\n  \n  This naturally seemed like a ML task, and to save on the number of meshing\n  operations needed, Bayesian Optimization is used to \"train\" a surrogate model,\n  then fine-tune it on the target STL model.\n  \n  The surrogate model is tuned into the following directions (these are\n  hard-coded):\n  1. Favorizing bigger cell sizes to produce meshes that are as coarse as\n  possible while detecting all important surface features. This is enforced by\n  applying a decay function to cell-size objective functions.\n  1. Producing Hex-based meshing, using [(open-source version of)\n  cfMesh's](https://cfmesh.com/cfmesh-open-source/) \`cartesianMesh\`. The tool's\n  workflow is already pretty automated, and all it needs is a small nudge\n  towards good cell sizes.\n  \n  The tuning stage can be configured into the following directions:\n  1. Favorizing meshes needing less than \`STAGE1_MAX_OCTREES\` levels of\n  refinement in order to control RAM usage during training. By default, fast\n  meshing operations requiring less than 16GB of RAM are promoted.\n  1. Controlling Bias towards features of the training dataset, through the\n  distributions of STL geometric features.\n  \n  &gt; [!IMPORTANT]\n  &gt; Experimental at best, still figuring out the best objective functions,\n  parameters to consider, and STL model types to train on.\n\n"
  else
    printf "meshingo - A cell-size recommendation system for CFD meshes;\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  meshingo COMMAND\n"
  printf "  meshingo [COMMAND] --help | -h\n"
  printf "  meshingo --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Install Python dependencies, assuming you have uv\n" "install  "
  printf "  %s   Run a 1st stage bayesian optimization, leveraging full runs of meshing tools to train a surrogate model. This will take some time\n" "stage1   "
  printf "  %s   Infer settings from a saved surrogate model, and run corresponding meshing case.\n" "validate "
  printf "  %s   Check if the stage 1 bayesian optimization produced a surrogate model that favorizes some parameters over the others.\n" "bias-scan"
  printf "  %s   Fine-tune surrogate model from stage 1 on target STL, and reach a verdict for the top three (3) \"good-enough\" cell sizes.\n" "stage2   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
meshingo_install_usage() {
  printf "meshingo install - Install Python dependencies, assuming you have uv\n\n"
  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  meshingo install\n"
  printf "  meshingo install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
meshingo_stage1_usage() {
  printf "meshingo stage1 - Run a 1st stage bayesian optimization, leveraging full runs of meshing tools to train a surrogate model. This will take some time\n\n"
  printf "Alias: s1, train\n"
  echo

  printf "%s\n" "Usage:"
  printf "  meshingo stage1 TRAINING_STLS [OPTIONS]\n"
  printf "  meshingo stage1 --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--stage1-name STAGE1-NAME (required)"
    printf "    Name for stage1 optimization problem\n"
    echo

    # :flag.usage
    printf "  %s\n" "--n-parallel-trials N-PARALLEL-TRIALS"
    printf "    Number of parallel trials for stage1 optimization run\n"
    printf "    %s\n" "Default: 2"
    echo

    # :flag.usage
    printf "  %s\n" "--n-trials N-TRIALS"
    printf "    Max total number of trials to run in stage 1 optimization\n"
    printf "    %s\n" "Default: 300"
    echo

    # :flag.usage
    printf "  %s\n" "--stopping-improvement STOPPING-IMPROVEMENT"
    printf "    Improvement bar for early stopping the stage 1 optimization\n"
    printf "    %s\n" "Default: 1e-3"
    echo

    # :flag.usage
    printf "  %s\n" "--trial-ttl TRIAL-TTL"
    printf "    Trial Time-To-Live in seconds\n"
    printf "    %s\n" "Default: 3000"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TRAINING_STLS"
    printf "    Path to a folder with STL models used for the 1st optimization run\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "STAGE1_MAX_OCTREES"
    printf "    Maximal allowed number of Octree levels generated by cfMesh tools.\n"
    printf "    %s\n" "Default: 9"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  meshingo train --stage1-name Meshingo --n-trials 300 training_dataset/\n"
    echo

  fi
}

# :command.usage
meshingo_validate_usage() {
  printf "meshingo validate - Infer settings from a saved surrogate model, and run corresponding meshing case.\n\n"
  printf "Alias: v\n"
  echo

  printf "%s\n" "Usage:"
  printf "  meshingo validate TARGET_STL [OPTIONS]\n"
  printf "  meshingo validate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--model MODEL (required)"
    printf "    Name for surrogate model\n"
    echo

    # :flag.usage
    printf "  %s\n" "--training-set TRAINING_SET (required)"
    printf "    Path to geometric_features.csv for the training dataset\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET_STL"
    printf "    Path to a target STL, used for model inference. Will use the same configs\n    used\n    to train the model, with the option to change environment variables.\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "STAGE1_MAX_OCTREES"
    printf "    Maximal allowed number of Octree levels generated by cfMesh tools.\n"
    printf "    %s\n" "Default: 9"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  meshingo validate --model stage1/Meshingo /my/model.stl\n"
    echo

  fi
}

# :command.usage
meshingo_bias_scan_usage() {
  printf "meshingo bias-scan - Check if the stage 1 bayesian optimization produced a surrogate model that favorizes some parameters over the others.\n\n"
  printf "Alias: bs\n"
  echo

  printf "%s\n" "Usage:"
  printf "  meshingo bias-scan [OPTIONS]\n"
  printf "  meshingo bias-scan --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--stage1-name STAGE1-NAME (required)"
    printf "    Name for stage1 optimization problem\n"
    echo

    # :flag.usage
    printf "  %s\n" "--threshold THRESHOLD"
    printf "    Maximal tolerable difference in feature importance for cell size objective\n"
    printf "    %s\n" "Default: 0.05"
    echo

    # :flag.usage
    printf "  %s\n" "--ignore"
    printf "    Don't fail even if the model is heavily biased\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  meshingo bias-scan --stage1-name Meshingo --threshold 0.1\n"
    echo

  fi
}

# :command.usage
meshingo_stage2_usage() {
  printf "meshingo stage2 - Fine-tune surrogate model from stage 1 on target STL, and reach a verdict for the top three (3) \"good-enough\" cell sizes.\n\n"
  printf "Alias: s2, predict\n"
  echo

  printf "%s\n" "Usage:"
  printf "  meshingo stage2 TARGET_STL [OPTIONS]\n"
  printf "  meshingo stage2 --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--stage1-name STAGE1-NAME (required)"
    printf "    Name for stage1 optimization problem\n"
    echo

    # :flag.usage
    printf "  %s\n" "--stage2-name STAGE2-NAME (required)"
    printf "    Name for stage2 optimization problem\n"
    echo

    # :flag.usage
    printf "  %s\n" "--n-parallel-trials N-PARALLEL-TRIALS"
    printf "    Number of parallel trials for stage1 optimization run\n"
    printf "    %s\n" "Default: 2"
    echo

    # :flag.usage
    printf "  %s\n" "--n-trials N-TRIALS"
    printf "    Max total number of trials to run in stage 1 optimization\n"
    printf "    %s\n" "Default: 300"
    echo

    # :flag.usage
    printf "  %s\n" "--stopping-improvement STOPPING-IMPROVEMENT"
    printf "    Improvement bar for early stopping the stage 1 optimization\n"
    printf "    %s\n" "Default: 1e-3"
    echo

    # :flag.usage
    printf "  %s\n" "--trial-ttl TRIAL-TTL"
    printf "    Trial Time-To-Live in seconds\n"
    printf "    %s\n" "Default: 3000"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET_STL"
    printf "    Path to the target STL to guess the cell size for\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  meshingo predict --stage1-name Meshingo --stage2-name Test\n  testing_dataset/model.stl\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
meshingo_install_command() {

  # src/install_command.sh
  git_root_folder=$(git rev-parse --show-toplevel)
  cd "${git_root_folder}" || { echo -e "\e[31m${git_root_folder}\e[0m not found. We rely on git to infer root folder!"; exit 1; }
  echo -e "Installing dependencies to \e[32m${git_root_folder}\e[0m"
  uv sync
  uv pip install -e .

}

# :command.function
meshingo_stage1_command() {

  # src/stage1_command.sh
  git_root_folder=$(git rev-parse --show-toplevel)
  opt_folder="${git_root_folder}/stage1"
  train_folder=$(realpath "${args[training_stls]}")
  cd "${train_folder}" || { echo -e "\e[31m${train_folder}\e[0m not found."; exit 1; }
  echo -e "Computing geometrical features of all STL files found in ${train_folder}"
  uv run compute-geometric-features  "${train_folder}"
  cd "${opt_folder}" || { echo -e "\e[31m${opt_folder}\e[0m not found. We rely on git to infer root folder!"; exit 1; }
  echo -e "Running \e[32mstage 1 \e[0mfor training the generic surrogate model ${args[--stage1-name]}..."
  uv run foamBO --config-name stage_1 \
      ++problem.name="${args[--stage1-name]}" \
      ++meta.n_trials="${args[--n-trials]}" \
      ++meta.n_parallel_trials="${args[--n-parallel-trials]}" \
      ++meta.ttl_trial="${args[--trial-ttl]}" \
      ++meta.stopping_strategy.improvement_bar="${args[--stopping-improvement]}" \

}

# :command.function
meshingo_validate_command() {

  # src/validate_command.sh
  git_root_folder=$(git rev-parse --show-toplevel)
  testing_stls="${git_root_folder}/testing_dataset"
  if [ "$(readlink -f "${args[target_stl]}")" != "$(readlink -f "$testing_stls/$(basename ${args[target_stl]})")" ]; then
      cp "${args[target_stl]}" "$testing_stls"
  fi
  if [ "$(readlink -f "${args[--training-set]}")" != "$(readlink -f "training_dataset/geometric_features.csv")" ]; then
      cp "${args[--training-set]}" training_dataset/geometric_features.csv
  fi
  echo -e "Computing geometrical features of all STL files found in ${testing_stls}"
  uv run compute-geometric-features  "${testing_stls}"
  echo -e "\e[32mValidation run \e[0mfor ${args[--model]} surrogate model..."
  uv run validate --name ${args[--model]} --target-stl ${args[target_stl]}

}

# :command.function
meshingo_bias_scan_command() {

  # src/bias_scan_command.sh
  git_root_folder=$(git rev-parse --show-toplevel)
  opt_folder="${git_root_folder}/stage1"
  ignore=""
  if [[ -n "${args[--ignore]}" ]]; then
    ignore="--ignore"
  fi
  uv run bias-geo-features --threshold "${args[--threshold]}" $ignore "${opt_folder}/${args[--stage1-name]}"

}

# :command.function
meshingo_stage2_command() {

  # src/stage2_command.sh
  git_root_folder=$(git rev-parse --show-toplevel)
  pred_folder="${git_root_folder}/stage2"
  testing_stls="${git_root_folder}/testing_dataset"
  if [ "$(readlink -f "${args[target_stl]}")" != "$(readlink -f "$testing_stls/$(basename ${args[target_stl]})")" ]; then
      cp "${args[target_stl]}" "$testing_stls"
  fi
  echo -e "Computing geometrical features of all STL files found in ${testing_stls}"
  uv run compute-geometric-features  "${testing_stls}"
  cd "${pred_folder}" || { echo -e "\e[31m${pred_folder}\e[0m not found. We rely on git to infer root folder!"; exit 1; }
  echo -e "Running \e[32mstage 2 \e[0mfor fine-tuning the generic surrogate model ${args[--stage1-name]} model"
  stl_name=$(basename "${args[target_stl]}")
  stl_name="${stl_name%.*}"
  uv run foamBO --config-name stage_2 \
      ++problem.name="${args[--stage2-name]}" \
      ++meta.n_trials="${args[--n-trials]}" \
      ++meta.n_parallel_trials="${args[--n-parallel-trials]}" \
      ++meta.ttl_trial="${args[--trial-ttl]}" \
      ++meta.case_run_command='["./Allrun.stage2", "'${stl_name}'", "'${args[--stage1-name]}'"]' \
      ++meta.stopping_strategy.improvement_bar="${args[--stopping-improvement]}"
  uv run validate --name "${args[--stage2-name]}" --target_stl "${args[target_stl]}"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        meshingo_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v git >/dev/null 2>&1; then
    printf "missing dependency: git\n" >&2
    printf "%s\n\n" "install git through your package manager" >&2
    missing_deps=1
  else
    deps['git']="$(command -v git | head -n1)"
  fi

  # :dependency.filter
  if ! command -v uv >/dev/null 2>&1; then
    printf "missing dependency: uv\n" >&2
    printf "%s\n\n" "install by running $(curl -LsSf https://astral.sh/uv/install.sh | sh)" >&2
    missing_deps=1
  else
    deps['uv']="$(command -v uv | head -n1)"
  fi

  # :dependency.filter
  if ! command -v cartesianMesh >/dev/null 2>&1; then
    printf "missing dependency: cartesianMesh\n" >&2
    printf "%s\n\n" "source etc/bashrc from an OpenFOAM installation with cfMesh compiled" >&2
    missing_deps=1
  else
    deps['cartesianMesh']="$(command -v cartesianMesh | head -n1)"
  fi

  # :dependency.filter
  if ! command -v surfaceCheck >/dev/null 2>&1; then
    printf "missing dependency: surfaceCheck\n" >&2
    printf "%s\n\n" "source etc/bashrc from an OpenFOAM installation" >&2
    missing_deps=1
  else
    deps['surfaceCheck']="$(command -v surfaceCheck | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    install | i)
      action="install"
      shift
      meshingo_install_parse_requirements "$@"
      shift $#
      ;;

    stage1 | s1 | train)
      action="stage1"
      shift
      meshingo_stage1_parse_requirements "$@"
      shift $#
      ;;

    validate | v)
      action="validate"
      shift
      meshingo_validate_parse_requirements "$@"
      shift $#
      ;;

    bias-scan | bs)
      action="bias-scan"
      shift
      meshingo_bias_scan_parse_requirements "$@"
      shift $#
      ;;

    stage2 | s2 | predict)
      action="stage2"
      shift
      meshingo_stage2_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      meshingo_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
meshingo_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        meshingo_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
meshingo_stage1_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        meshingo_stage1_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export STAGE1_MAX_OCTREES="${STAGE1_MAX_OCTREES:-9}"

  env_var_names+=("STAGE1_MAX_OCTREES")

  # :command.command_filter
  action="stage1"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --stage1-name)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--stage1-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--stage1-name requires an argument: --stage1-name STAGE1-NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --n-parallel-trials)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--n-parallel-trials']="$2"
          shift
          shift
        else
          printf "%s\n" "--n-parallel-trials requires an argument: --n-parallel-trials N-PARALLEL-TRIALS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --n-trials)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--n-trials']="$2"
          shift
          shift
        else
          printf "%s\n" "--n-trials requires an argument: --n-trials N-TRIALS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --stopping-improvement)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--stopping-improvement']="$2"
          shift
          shift
        else
          printf "%s\n" "--stopping-improvement requires an argument: --stopping-improvement STOPPING-IMPROVEMENT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --trial-ttl)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--trial-ttl']="$2"
          shift
          shift
        else
          printf "%s\n" "--trial-ttl requires an argument: --trial-ttl TRIAL-TTL" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['training_stls']+x} ]]; then
          args['training_stls']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['training_stls']+x} ]]; then
    printf "missing required argument: TRAINING_STLS\nusage: meshingo stage1 TRAINING_STLS [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--stage1-name']+x} ]]; then
    printf "missing required flag: --stage1-name STAGE1-NAME\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--n-parallel-trials']:-} ]] || args['--n-parallel-trials']="2"
  [[ -n ${args['--n-trials']:-} ]] || args['--n-trials']="300"
  [[ -n ${args['--stopping-improvement']:-} ]] || args['--stopping-improvement']="1e-3"
  [[ -n ${args['--trial-ttl']:-} ]] || args['--trial-ttl']="3000"

}

# :command.parse_requirements
meshingo_validate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        meshingo_validate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export STAGE1_MAX_OCTREES="${STAGE1_MAX_OCTREES:-9}"

  env_var_names+=("STAGE1_MAX_OCTREES")

  # :command.command_filter
  action="validate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --model)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--model']="$2"
          shift
          shift
        else
          printf "%s\n" "--model requires an argument: --model MODEL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --training-set)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--training-set']="$2"
          shift
          shift
        else
          printf "%s\n" "--training-set requires an argument: --training-set TRAINING_SET" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target_stl']+x} ]]; then
          args['target_stl']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['target_stl']+x} ]]; then
    printf "missing required argument: TARGET_STL\nusage: meshingo validate TARGET_STL [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--model']+x} ]]; then
    printf "missing required flag: --model MODEL\n" >&2
    exit 1
  fi
  if [[ -z ${args['--training-set']+x} ]]; then
    printf "missing required flag: --training-set TRAINING_SET\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
meshingo_bias_scan_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        meshingo_bias_scan_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bias-scan"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --stage1-name)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--stage1-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--stage1-name requires an argument: --stage1-name STAGE1-NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --threshold)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--threshold']="$2"
          shift
          shift
        else
          printf "%s\n" "--threshold requires an argument: --threshold THRESHOLD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ignore)

        # :flag.case_no_arg
        args['--ignore']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--stage1-name']+x} ]]; then
    printf "missing required flag: --stage1-name STAGE1-NAME\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--threshold']:-} ]] || args['--threshold']="0.05"

}

# :command.parse_requirements
meshingo_stage2_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        meshingo_stage2_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="stage2"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --stage1-name)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--stage1-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--stage1-name requires an argument: --stage1-name STAGE1-NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --stage2-name)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--stage2-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--stage2-name requires an argument: --stage2-name STAGE2-NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --n-parallel-trials)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--n-parallel-trials']="$2"
          shift
          shift
        else
          printf "%s\n" "--n-parallel-trials requires an argument: --n-parallel-trials N-PARALLEL-TRIALS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --n-trials)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--n-trials']="$2"
          shift
          shift
        else
          printf "%s\n" "--n-trials requires an argument: --n-trials N-TRIALS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --stopping-improvement)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--stopping-improvement']="$2"
          shift
          shift
        else
          printf "%s\n" "--stopping-improvement requires an argument: --stopping-improvement STOPPING-IMPROVEMENT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --trial-ttl)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--trial-ttl']="$2"
          shift
          shift
        else
          printf "%s\n" "--trial-ttl requires an argument: --trial-ttl TRIAL-TTL" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target_stl']+x} ]]; then
          args['target_stl']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['target_stl']+x} ]]; then
    printf "missing required argument: TARGET_STL\nusage: meshingo stage2 TARGET_STL [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--stage1-name']+x} ]]; then
    printf "missing required flag: --stage1-name STAGE1-NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--stage2-name']+x} ]]; then
    printf "missing required flag: --stage2-name STAGE2-NAME\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--n-parallel-trials']:-} ]] || args['--n-parallel-trials']="2"
  [[ -n ${args['--n-trials']:-} ]] || args['--n-trials']="300"
  [[ -n ${args['--stopping-improvement']:-} ]] || args['--stopping-improvement']="1e-3"
  [[ -n ${args['--trial-ttl']:-} ]] || args['--trial-ttl']="3000"

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "install") meshingo_install_command ;;
    "stage1") meshingo_stage1_command ;;
    "validate") meshingo_validate_command ;;
    "bias-scan") meshingo_bias_scan_command ;;
    "stage2") meshingo_stage2_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
